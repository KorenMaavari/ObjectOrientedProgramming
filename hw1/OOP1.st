Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'initialize-release' stamp: 'KM 12/3/2024 21:38'!initialize    "This method initializes a new instance of the Monom class (or similar object) with default values.    Specifically, it sets both the exponent (exp) and coefficient (coef) to zero, representing a zero monomial."    exp := 0.    "Set the instance variable 'exp' (exponent) to 0.    This means the term is constant or zero (e.g., 0x^0 = 0)."    coef := 0.    "Set the instance variable 'coef' (coefficient) to 0.    This represents that the term has no value, effectively making it a zero monomial."    ^self    "Return the current instance (self) to allow method chaining or to indicate that the initialization is complete."    "Why use initialize?    - Object Initialization: This method ensures that every new instance of the class starts with consistent default values.    - Simplicity: By setting default values to zero, the monomial is initially a neutral element (representing 0).    - Consistency: Adhering to Smalltalk conventions, 'initialize' is a common way to define default instance values during object creation."! !!Monom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:37'!coef    "This method provides access to the instance variable 'coef', which likely represents the coefficient     associated with a polynomial term or mathematical expression. It acts as a simple getter method."    ^coef    "Return the value of the instance variable 'coef'.    This allows external methods or objects to retrieve the value of 'coef' for inspection or further computation."    "Why use an accessor method?    - Encapsulation: Instead of directly accessing the instance variable, this method provides controlled access,       adhering to object-oriented programming principles.    - Flexibility: By using a method to access 'coef', additional logic (e.g., validation, transformation, or logging)       could be added in the future without requiring changes to external code that uses this method."! !!Monom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:37'!coef: anInteger    "This method sets the value of the instance variable 'coef' to the given integer (anInteger).    It ensures that the input is valid (an integer) before assigning it."    (anInteger isKindOf: Integer)        "Check if the input 'anInteger' is an instance of Integer.        This ensures the method only accepts valid numerical inputs."        ifTrue: [            "If the input is valid, assign it to 'coef'."            coef := anInteger.            "Set the instance variable 'coef' to the provided integer value."            ^self            "Return the current instance (self) to allow method chaining or further operations."        ]        ifFalse: [            "If the input is not an integer, raise an error to signal invalid input."            self error: 'invalid input'        ].! !!Monom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:38'!derivative    "This method calculates the derivative of a monomial represented by the current instance.    It follows standard calculus rules for differentiation:    - The derivative of ax^n is n*ax^(n-1).    - Special cases: The derivative of a constant (exp = 0) or a zero coefficient (coef = 0) is zero."    | monomDeriative |    "Declare a local variable 'monomDeriative' to hold the resulting monomial after differentiation."    monomDeriative := Monom new.    "Initialize 'monomDeriative' as a new Monom instance.     This will store the derivative of the current monomial."    ((exp = 0) or: [coef = 0])        "Check for special cases:        - If the exponent (exp) is 0, the monomial is a constant (e.g., 5x^0 = 5), and its derivative is 0.        - If the coefficient (coef) is 0, the monomial is effectively zero, and its derivative is also zero."        ifTrue: [            ^monomDeriative            "Return 'monomDeriative' as a zero monomial.             A new Monom instance without explicit coef or exp set defaults to representing 0."        ]        ifFalse: [            "For all other cases, compute the derivative using standard differentiation rules."            monomDeriative coef: ((self coef) * (self exp)).            "Set the coefficient of 'monomDeriative' to the product of the current coefficient (coef)             and the exponent (exp), as per the derivative formula."            monomDeriative exp: ((self exp) - 1).            "Set the exponent of 'monomDeriative' to one less than the current exponent (exp),            reflecting the power reduction in differentiation."            ^monomDeriative            "Return the resulting monomial representing the derivative."        ].! !!Monom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:36'!exp    "This method provides access to the instance variable 'exp', which likely represents an exponent     associated with a polynomial or mathematical term. It acts as a simple getter method."    ^exp    "Return the value of the instance variable 'exp'.    This allows external methods or objects to retrieve the value of 'exp' for inspection or further computation."    "Why use an accessor method?    - Encapsulation: Instead of directly accessing the instance variable, this method provides controlled access,       adhering to object-oriented programming principles.    - Flexibility: If the internal representation of 'exp' changes in the future, this method can be updated without       affecting external code."! !!Monom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:37'!exp: anInteger    "This method sets the value of the instance variable 'exp' to the given integer (anInteger).     It ensures that the input is valid (a non-negative integer) before assigning it."    ((anInteger isKindOf: Integer))        "Check if the input 'anInteger' is an instance of Integer.        This ensures the method works only with valid numerical inputs."        ifTrue: [            "If the input is a valid integer, proceed with further validation."            (anInteger >= 0)                "Check if the integer is non-negative.                Negative exponents are considered invalid in this context."                ifTrue: [                    "If the input is a non-negative integer, assign it to 'exp'."                    exp := anInteger.                    "Set the instance variable 'exp' to the provided value."                    ^self                    "Return the current instance (self) to allow method chaining or further operations."                ]                ifFalse: [                    "If the integer is negative, raise an error to signal invalid input."                    self error: 'invalid input'                ]        ]        ifFalse: [            "If the input is not an integer, raise an error to signal invalid input."            self error: 'invalid input'        ].! !Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream methodsFor: 'getting' stamp: 'KM 11/28/2024 23:33'!block    "This method simply returns the current state of the instance variable 'block'.     The 'block' is likely a closure or a functional construct that holds custom logic for evaluation or computation."    ^block    "Return the value of the instance variable 'block'.     This allows external methods or clients to access the stored block for evaluation or inspection."    "Note:    - 'block' is assumed to be a closure (a function or lambda-like construct) that was previously defined and stored in the instance variable.    - This design pattern is often used to allow dynamic behavior, as the block can encapsulate reusable logic.    - By providing this accessor method, the class offers controlled exposure to its internal state, adhering to encapsulation principles."! !!PolyStream methodsFor: 'initialize-release' stamp: 'KM 11/25/2024 19:58'!initialize	block := [:evalValue :filters | 0 ].	"	THIS BLOCK RETURNS AN INTEGER WHICH IS THE RESULT OF x=evalValue IN THE POLYNOM.	PARAMETER evalValue: REPRESENTS THE x TO CALCULATE.	PARAMETER filters: ALL THE EXPONENTS THAT NEED TO BE FILTERED.	"! !!PolyStream methodsFor: 'actions' stamp: 'KM 11/28/2024 23:33'!add: aPolyStream    "This method adds the behavior of another PolyStream (aPolyStream) to the current instance.    It validates the input to ensure it is a PolyStream, retrieves its block, and then combines the current block     with the block from aPolyStream into a new block."    (aPolyStream isKindOf: PolyStream)        "Check if the argument 'aPolyStream' is an instance of the PolyStream class.        This ensures that the method only operates on valid PolyStream objects."        ifTrue: [            "If the input is valid, proceed with adding its behavior to the current PolyStream."                        | currentState aPolyBlock |             "Declare local variables:            - currentState: To store the current block logic of this instance.            - aPolyBlock: To store the block logic of the input PolyStream (aPolyStream)."                        currentState := block.            "Store the current block of this instance in 'currentState' for use in the new block."                        aPolyBlock := aPolyStream block.            "Retrieve the block from the input PolyStream (aPolyStream) and store it in 'aPolyBlock'.            This allows us to access and use the logic defined in the other PolyStream."                        block := [:evalValue :filters |                 "Redefine the block for this PolyStream. The new block combines the logic of the current block                 and the block from aPolyStream."                                (currentState value: evalValue value: filters)                 + (aPolyBlock value: evalValue value: filters)                "The new block calculates the sum of:                1. The result of the current block's logic.                2. The result of the other PolyStream's block logic.                Both are evaluated with the same 'evalValue' and 'filters' inputs."            ].                        ^self            "Return the current instance (self) to allow method chaining or further operations."        ]        ifFalse: [            "If the input is not a valid PolyStream, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!PolyStream methodsFor: 'actions' stamp: 'KM 11/28/2024 23:33'!addCoef: coef withExp: exp    "This method adds a coefficient (coef) with its corresponding exponent (exp) to a calculation block.    It validates the inputs and defines a new block of logic to incorporate the provided coefficient and exponent."        ((coef isKindOf: Integer) and: (exp isKindOf: Integer))        "Check if both coef and exp are integers. This ensures that the method works only with valid numerical inputs."        ifTrue: [            "If both coef and exp are integers, proceed with the implementation."                        | currentState calcResult | "Declare local variables to store the current state of the block and calculation results."                        (exp >= 0)                "Check if the exponent (exp) is non-negative.                Negative exponents are considered invalid in this context, so the code handles them as errors."                ifFalse: [                    self error: 'invalid input'.                    "If the exponent is negative, raise an error to signal invalid input to the user."                ].                        currentState := block.            "Store the current block state in the variable 'currentState' to preserve its existing behavior for reuse later."                        block := [:evalValue :filters |                "Redefine the block with a new behavior. This block takes two parameters:                - evalValue: A value to evaluate (e.g., x in a polynomial).                - filters: A collection that may exclude certain exponents from being added to the result."                                (filters includes: exp)                    "Check if the exponent (exp) is included in the provided filters.                    Filters are used to decide whether to exclude certain terms from the computation."                    ifTrue: [                        "If the exponent is filtered, do not add the term (coef * evalValue^exp) to the result."                        calcResult := (currentState value: evalValue value: filters).                        "Simply evaluate the current block without modifying it."                    ]                    ifFalse: [                        "If the exponent is not filtered, compute the term and add it to the result."                        calcResult := (currentState value: evalValue value: filters) + (coef * (evalValue raisedTo: exp)).                        "Add the current state's evaluation to the new term (coef * evalValue^exp)."                    ].                                calcResult.                "Return the calculated result."            ].                        ^self            "Return the current instance (self) to allow method chaining or further operations."        ]        ifFalse: [            "If either coef or exp is not an integer, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!PolyStream methodsFor: 'actions' stamp: 'KM 11/28/2024 23:34'!eval: anInteger    "This method evaluates the polynomial for a given integer value (anInteger).    It validates the input, initializes an empty filter set, and evaluates the block using the provided integer."    (anInteger isKindOf: Integer)        "Check if the input 'anInteger' is an instance of Integer.        This ensures that the method operates only with valid numerical inputs."        ifTrue: [            "If the input is valid, proceed with the evaluation."            | emptyFilter |            "Declare a local variable 'emptyFilter' to hold an empty set for filters."            emptyFilter := Set new.            "Initialize 'emptyFilter' as a new, empty set.            This ensures no filters are applied during the evaluation of the polynomial."            ^ block value: anInteger value: emptyFilter.            "Evaluate the block with the provided integer ('anInteger') and the empty filter set ('emptyFilter').            The block's logic will now execute, using 'anInteger' as the evaluation value and applying no filters."        ]        ifFalse: [            "If the input is not a valid Integer, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!PolyStream methodsFor: 'actions' stamp: 'KM 11/28/2024 23:34'!filter: aSet    "This method allows filtering of terms in the polynomial by incorporating a set of filters (aSet).    It creates a copy of the provided set to ensure immutability, modifies the block to include the filters,     and ensures future changes to the original set do not affect the behavior of the polynomial."    | currentState tempASet |    "Declare local variables:    - currentState: To store the current block's logic temporarily.    - tempASet: A copy of the input set (aSet) to avoid side effects from external modifications."    tempASet := aSet copy.    "Create a copy of the input set (aSet).     This ensures that any future changes to the original set (aSet) outside this method do not affect the polynomial's behavior."    "Why copy the set?    - To maintain the integrity of the filtering logic in the polynomial.    - Prevent unintended side effects from external code modifying the original set."    currentState := block.    "Store the current block in 'currentState' for reuse in the new block logic."    block := [:evalValue :filters |        "Redefine the block to incorporate the filtering logic.         The new block will consider both the existing filters (tempASet) and any additional filters passed as arguments."        tempASet addAll: filters.        "Merge the filters from the input (filters) into tempASet.         This allows the block to dynamically adapt its filtering logic based on runtime inputs."        currentState value: evalValue value: tempASet        "Evaluate the current block (currentState) with the updated filters (tempASet) and the given evalValue.        This ensures the polynomial's logic respects both the existing and newly added filters."    ].    ^self    "Return the current instance (self) to allow method chaining or further operations."! !!PolyStream methodsFor: 'actions' stamp: 'KM 11/28/2024 23:34'!multiplyBy: anInteger    "This method multiplies the result of the current block by a given integer (anInteger).    It validates the input to ensure it is an Integer and modifies the block to include the multiplication logic."    (anInteger isKindOf: Integer)        "Check if the input 'anInteger' is an instance of Integer.        This ensures that the method only works with valid numerical inputs."        ifTrue: [            "If the input is valid, proceed to redefine the block with multiplication logic."            | currentState |            "Declare a local variable 'currentState' to temporarily store the current block's logic."            currentState := block.            "Store the current block in 'currentState' for reuse in the new block definition."            block := [:evalValue :filters |                 "Redefine the block to multiply its result by 'anInteger'."                anInteger * (currentState value: evalValue value: filters)                "Evaluate the current block with the given evalValue and filters, then multiply the result by 'anInteger'.                This effectively scales the output of the current block by the specified integer."            ].            ^self            "Return the current instance (self) to allow method chaining or further operations."        ]        ifFalse: [            "If the input is not an Integer, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!PolyStream methodsFor: 'actions' stamp: 'KM 11/28/2024 23:34'!substitute: anInteger    "This method substitutes the evaluation value (evalValue) with its scaled version (evalValue * anInteger).    It validates the input to ensure it is a non-zero integer and then modifies the block accordingly."    (anInteger isKindOf: Integer)        "Check if the input 'anInteger' is an Integer.        This ensures the method only operates on valid numerical inputs."        ifTrue: [            "If the input is valid, proceed with the substitution logic."                        (anInteger = 0)                "Check if the input integer is zero.                Zero is considered invalid in this context because multiplying evalValue by zero would eliminate its contribution entirely."                ifTrue: [                    self error: 'invalid input'.                    "Raise an error if the input is zero, signaling invalid input."                ]                                ifFalse: [                    "If the input is a valid, non-zero integer, proceed to redefine the block."                    | currentState |                    "Declare a local variable 'currentState' to temporarily store the current block's logic."                                        currentState := block.                    "Store the current block in 'currentState' for reuse in the new block logic."                                        block := [:evalValue :filters |                        "Redefine the block to scale 'evalValue' by 'anInteger' before passing it to the current block's logic."                                                currentState value: (evalValue * anInteger) value: filters                        "Evaluate the current block with the modified evalValue (scaled by anInteger) and the original filters.                        This effectively applies the substitution logic dynamically."                    ].                                        ^self                    "Return the current instance (self) to allow method chaining or further operations."                ]        ]        ifFalse: [            "If the input is not an Integer, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:50'!add: aPolynom    "This method adds the given polynomial (aPolynom) to the current polynomial and returns a new polynomial     representing the result. It ensures that the addition does not alter the original polynomials."    | resultPolynom tempPoly |    "Declare local variables:    - resultPolynom: To store the resulting polynomial after the addition.    - tempPoly: To create a copy of the given polynomial (aPolynom)."    (aPolynom isKindOf: Polynom)        "Check if the input 'aPolynom' is an instance of the Polynom class.        This ensures that the method operates only on valid Polynom objects."        ifTrue: [            "If the input is valid, proceed with the addition logic."            resultPolynom := Polynom new.            "Initialize 'resultPolynom' as a new, empty polynomial to store the sum of the two polynomials."            tempPoly := Polynom new.            "Initialize 'tempPoly' as a new polynomial to hold a copy of 'aPolynom'."            (aPolynom monoms) do: [ :value |                "Iterate over each monomial in the given polynomial (aPolynom)."                | tempMonom |                "Declare a local variable 'tempMonom' to represent the copied monomial."                tempMonom := Monom new.                "Create a new Monom instance to copy the current monomial."                tempMonom exp: (value exp); coef: (value coef).                "Set the exponent and coefficient of the new monomial to match the current monomial in aPolynom."                tempPoly addMonom: tempMonom.                "Add the copied monomial to 'tempPoly' to ensure future changes to aPolynom do not affect the result."            ].            "This block ensures that 'tempPoly' is a deep copy of 'aPolynom'."            monoms keysAndValuesDo: [ :exp :aMonom |                "Iterate over the current polynomial's monomials (monoms)."                resultPolynom addMonom: aMonom.                "Add each monomial to 'resultPolynom'."            ].            "This adds all monomials from the current polynomial to the result."            (tempPoly monoms) keysAndValuesDo: [ :exp :aMonom |                "Iterate over the copied monomials from 'tempPoly'."                resultPolynom addMonom: aMonom.                "Add each monomial from the copied polynomial (tempPoly) to 'resultPolynom'."            ].            "This adds all monomials from the copied aPolynom to the result."            ^ resultPolynom            "Return the resulting polynomial after addition."        ]        ifFalse: [            "If the input is not a valid Polynom object, raise an error to signal invalid input."            self error: 'Invalid input.'        ].! !!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:45'!addMonom: aMonom    "This method adds a monomial (aMonom) to the polynomial represented by the receiver.    If a monomial with the same exponent already exists, their coefficients are combined.    If the coefficient of the resulting monomial is zero, the term is removed."    (aMonom isKindOf: Monom)        "Check if the input 'aMonom' is an instance of the Monom class.        This ensures that the method only works with valid Monom objects."        ifTrue: [            | newMon tempCoef |            "Declare local variables:            - newMon: A Monom object to hold the term being added or updated.            - tempCoef: A temporary variable to store the sum of coefficients when combining terms."            (aMonom coef = 0)                "Check if the coefficient of 'aMonom' is 0. A monomial with a zero coefficient has no effect on the polynomial."                ifTrue: [^self].                "If the coefficient is 0, do nothing and return 'self'. This avoids unnecessary modifications."            newMon := monoms at: (aMonom exp) ifAbsent: [nil].            "Retrieve an existing monomial from 'monoms' with the same exponent as 'aMonom'.            If no such monomial exists, 'nil' is returned."            (newMon isNil)                "Check if a monomial with the same exponent was found."                ifTrue: [                    newMon := Monom new.                    "If no existing monomial is found, create a new Monom instance."                    newMon coef: (aMonom coef).                    "Set the coefficient of the new monomial to match 'aMonom'."                ]                ifFalse: [                    "If a monomial with the same exponent already exists, combine their coefficients."                    tempCoef := (newMon coef) + (aMonom coef).                    "Calculate the new coefficient by adding the coefficients of the existing and incoming monomials."                    newMon coef: tempCoef.                    "Update the coefficient of the existing monomial."                    monoms removeKey: (aMonom exp).                    "Remove the existing monomial from the dictionary to prepare for reinsertion."                ].            newMon exp: (aMonom exp).            "Set the exponent of the new or updated monomial to match 'aMonom'."            (newMon coef = 0)                "Check if the resulting monomial's coefficient is zero."                ifFalse: [                    monoms at: (aMonom exp) put: newMon.                    "If the coefficient is not zero, add the new or updated monomial to the dictionary."                ].                        ^self            "Return 'self' to allow method chaining or further operations."        ]        ifFalse: [            "If the input is not a valid Monom object, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:48'!asDictionary    "This method converts the collection of monomials ('monoms') in the polynomial into a Dictionary.    Each key in the Dictionary represents the exponent of a monomial, and the corresponding value is the coefficient."    | resultDict |    "Declare a local variable 'resultDict' to store the resulting Dictionary."    resultDict := Dictionary new.    "Initialize 'resultDict' as a new, empty Dictionary to hold the polynomial's terms."    monoms do: [ :monom |        "Iterate over each monomial in the collection ('monoms')."        monom coef = 0            "Check if the coefficient of the current monomial is zero."            ifTrue: [                "If the coefficient is zero, skip this monomial.                Terms with a coefficient of zero do not contribute to the polynomial."            ]            ifFalse: [                "If the coefficient is non-zero, add it to the Dictionary.                The key is the exponent (monom exp), and the value is the coefficient (monom coef)."                resultDict at: (monom exp) put: (monom coef).            ].    ].    ^ resultDict    "Return the resulting Dictionary representing the polynomial.    This Dictionary contains all non-zero terms, with their exponents as keys and coefficients as values."! !!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:48'!derivative    "This method computes the derivative of the polynomial by calculating the derivative of each monomial in the polynomial.    The resulting polynomial is returned as a new instance."    | resultPolynom |    "Declare a local variable 'resultPolynom' to store the resulting polynomial after differentiation."    resultPolynom := Polynom new.    "Initialize 'resultPolynom' as a new, empty polynomial to hold the derivative of the current polynomial."    monoms do: [ :monom |        "Iterate over each monomial in the collection ('monoms')."        resultPolynom addMonom: (monom derivative).        "Compute the derivative of the current monomial by calling its 'derivative' method.        Add the resulting monomial to 'resultPolynom' using 'addMonom:'."    ].    ^ resultPolynom    "Return the resulting polynomial ('resultPolynom') that contains the derivatives of all non-zero monomials in the original polynomial."! !!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:49'!eval: anInteger    "This method evaluates the polynomial at a given integer value (anInteger).    The method calculates the sum of the values of all monomials in the polynomial, substituting 'anInteger' for the variable."    | result |    "Declare a local variable 'result' to accumulate the evaluation result of the polynomial."    result := 0.    "Initialize 'result' to 0. This serves as the starting value for the summation."    (anInteger isKindOf: Integer)        "Check if the input 'anInteger' is an instance of Integer.        This ensures the method only operates on valid numerical inputs."        ifTrue: [            "If the input is valid, proceed with the evaluation."            monoms do: [ :value |                "Iterate over each monomial in the collection ('monoms')."                | temp adden |                "Declare local variables:                - temp: To hold the evaluation result of the current monomial.                - adden: To temporarily store the previous accumulated result."                adden := result.                "Store the current value of 'result' in 'adden' before adding the value of the current monomial."                (value exp = 0)                    "Check if the exponent of the current monomial is zero.                     Avoid evaluating 0^0, as it is mathematically undefined."                    ifTrue: [                        temp := value coef.                        "If the exponent is zero, the value of the monomial is simply its coefficient."                    ]                    ifFalse: [                        temp := (value coef) * (anInteger raisedTo: (value exp)).                        "If the exponent is not zero, evaluate the monomial as:                        coefficient * (anInteger raised to the power of the exponent)."                    ].                result := temp + adden.                "Add the value of the current monomial ('temp') to the accumulated result ('adden')."            ].            ^result            "Return the final evaluation result after summing all monomials."        ]        ifFalse: [            "If the input is not an integer, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:45'!monoms    "This method provides access to the instance variable 'monoms', which likely represents a collection     of monomials in a polynomial. It acts as a getter method, adhering to object-oriented design principles."    ^monoms    "Return the value of the instance variable 'monoms'.    This allows external methods or objects to access the collection of monomials for inspection or manipulation."    "Why use an accessor method?    - Encapsulation: Instead of directly accessing the instance variable, this method provides controlled access,       maintaining the principles of object-oriented programming.    - Flexibility: Using an accessor method allows additional logic to be added in the future (e.g., validation,       transformation, or logging) without affecting external code."! !!Polynom methodsFor: 'instance methods' stamp: 'KM 12/3/2024 21:47'!multiplyByMonom: aMonom    "This method multiplies the current polynomial by a given monomial (aMonom).    Each term (monom) in the polynomial is multiplied by the given monomial, and the result is updated in the polynomial."    | resPolynom |    "Declare a local variable 'resPolynom' to temporarily store the resulting polynomial after the multiplication."    (aMonom isKindOf: Monom)        "Check if the input 'aMonom' is an instance of the Monom class.        This ensures that the method operates only on valid Monom objects."        ifTrue: [            "If the input is valid, proceed with the multiplication logic."            resPolynom := Polynom new.            "Initialize 'resPolynom' as a new, empty polynomial to store the result of the multiplication."            monoms do: [ :value |                "Iterate over each monomial (value) in the current polynomial ('monoms')."                | tempExp tempCoef tempMonom |                "Declare local variables:                - tempExp: To hold the new exponent after adding exponents from 'value' and 'aMonom'.                - tempCoef: To hold the new coefficient after multiplying coefficients from 'value' and 'aMonom'.                - tempMonom: To represent the resulting monomial after multiplication."                tempExp := (value exp) + (aMonom exp).                "Calculate the new exponent by adding the exponents of the current monomial and 'aMonom'."                tempCoef := (value coef) * (aMonom coef).                "Calculate the new coefficient by multiplying the coefficients of the current monomial and 'aMonom'."                tempMonom := Monom new.                "Create a new Monom instance to represent the resulting monomial."                tempMonom exp: tempExp; coef: tempCoef.                "Set the new monomial's exponent and coefficient to the calculated values."                resPolynom addMonom: tempMonom.                "Add the resulting monomial to the 'resPolynom'."            ].            "This loop computes the product of the current polynomial with 'aMonom' and stores the result in 'resPolynom'."            monoms removeAll.            "Clear the current polynomial's monoms to prepare for updating it with the result."            (aMonom coef = 0)                "Check if the coefficient of 'aMonom' is zero.                Multiplying by a zero monomial results in a zero polynomial."                ifFalse: [                    "If the coefficient is non-zero, update the current polynomial with the resulting monomials."                    monoms addAll: (resPolynom monoms).                ].            ^self            "Return the current instance (self) to allow method chaining or further operations."        ]        ifFalse: [            "If the input is not a valid Monom object, raise an error to signal invalid input."            self error: 'invalid input'.        ].! !!Polynom methodsFor: 'initialize-release' stamp: 'KM 12/3/2024 21:44'!initialize    "This method initializes a new instance of the class, setting up its internal state with default values.    Specifically, it initializes the 'monoms' instance variable as an empty dictionary to store monomials."    monoms := Dictionary new.    "Create a new, empty Dictionary and assign it to the instance variable 'monoms'.    This dictionary will likely be used to store monomials with keys representing exponents and values representing coefficients.        Why use a Dictionary?    - Efficiency: A Dictionary allows fast lookups, insertions, and deletions, making it ideal for managing terms of a polynomial.    - Flexibility: It supports dynamic addition of terms with unique keys (exponents) without requiring predefined sizes or structures."    ^self    "Return the current instance (self) to indicate that the initialization is complete and to allow method chaining."    "Why use initialize?    - Object Initialization: This method ensures that every new instance starts with a consistent and usable default state.    - Encapsulation: By defining initialization logic in a dedicated method, the internal setup of the object remains hidden from external code.    - Convention: In Smalltalk, 'initialize' is the standard method for setting up instance variables when an object is created."! !